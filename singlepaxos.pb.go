// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: singlepaxos.proto

/*
	Package singlepaxos is a generated protocol buffer package.

	It is generated from these files:
		singlepaxos.proto

	It has these top-level messages:
		Heartbeat
		Round
		Value
		Response
		PrepareMsg
		PromiseMsg
		AcceptMsg
		LearnMsg
		Empty
*/
package singlepaxos

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/relab/gorums"
import _ "github.com/gogo/protobuf/gogoproto"

import bytes "bytes"
import binary "encoding/binary"
import trace "golang.org/x/net/trace"
import grpc "google.golang.org/grpc"
import codes "google.golang.org/grpc/codes"
import status "google.golang.org/grpc/status"
import fnv "hash/fnv"
import io "io"
import log "log"
import net "net"
import sort "sort"
import strconv "strconv"
import strings "strings"
import sync "sync"
import time "time"

import context "golang.org/x/net/context"

import reflect "reflect"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type Heartbeat struct {
	Id uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *Heartbeat) Reset()                    { *m = Heartbeat{} }
func (*Heartbeat) ProtoMessage()               {}
func (*Heartbeat) Descriptor() ([]byte, []int) { return fileDescriptorSinglepaxos, []int{0} }

func (m *Heartbeat) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

type Round struct {
	Rnd uint32 `protobuf:"varint,1,opt,name=rnd,proto3" json:"rnd,omitempty"`
}

func (m *Round) Reset()                    { *m = Round{} }
func (*Round) ProtoMessage()               {}
func (*Round) Descriptor() ([]byte, []int) { return fileDescriptorSinglepaxos, []int{1} }

func (m *Round) GetRnd() uint32 {
	if m != nil {
		return m.Rnd
	}
	return 0
}

type Value struct {
	ClientRequest string `protobuf:"bytes,1,opt,name=clientRequest,proto3" json:"clientRequest,omitempty"`
}

func (m *Value) Reset()                    { *m = Value{} }
func (*Value) ProtoMessage()               {}
func (*Value) Descriptor() ([]byte, []int) { return fileDescriptorSinglepaxos, []int{2} }

func (m *Value) GetClientRequest() string {
	if m != nil {
		return m.ClientRequest
	}
	return ""
}

type Response struct {
	ClientResponse string `protobuf:"bytes,1,opt,name=clientResponse,proto3" json:"clientResponse,omitempty"`
}

func (m *Response) Reset()                    { *m = Response{} }
func (*Response) ProtoMessage()               {}
func (*Response) Descriptor() ([]byte, []int) { return fileDescriptorSinglepaxos, []int{3} }

func (m *Response) GetClientResponse() string {
	if m != nil {
		return m.ClientResponse
	}
	return ""
}

// PrepareMsg is sent by the Proposer to start a new round, rnd.
type PrepareMsg struct {
	Rnd uint32 `protobuf:"varint,1,opt,name=rnd,proto3" json:"rnd,omitempty"`
}

func (m *PrepareMsg) Reset()                    { *m = PrepareMsg{} }
func (*PrepareMsg) ProtoMessage()               {}
func (*PrepareMsg) Descriptor() ([]byte, []int) { return fileDescriptorSinglepaxos, []int{4} }

func (m *PrepareMsg) GetRnd() uint32 {
	if m != nil {
		return m.Rnd
	}
	return 0
}

// PromiseMsg is the reply from an Acceptor to the Proposer in response to a PrepareMsg.
// The Acceptor will only respond if the PrepareMsg.rnd > Acceptor.rnd.
type PromiseMsg struct {
	Rnd  uint32 `protobuf:"varint,1,opt,name=rnd,proto3" json:"rnd,omitempty"`
	Vrnd uint32 `protobuf:"varint,2,opt,name=vrnd,proto3" json:"vrnd,omitempty"`
	Vval *Value `protobuf:"bytes,3,opt,name=vval" json:"vval,omitempty"`
}

func (m *PromiseMsg) Reset()                    { *m = PromiseMsg{} }
func (*PromiseMsg) ProtoMessage()               {}
func (*PromiseMsg) Descriptor() ([]byte, []int) { return fileDescriptorSinglepaxos, []int{5} }

func (m *PromiseMsg) GetRnd() uint32 {
	if m != nil {
		return m.Rnd
	}
	return 0
}

func (m *PromiseMsg) GetVrnd() uint32 {
	if m != nil {
		return m.Vrnd
	}
	return 0
}

func (m *PromiseMsg) GetVval() *Value {
	if m != nil {
		return m.Vval
	}
	return nil
}

// AcceptMsg is sent by the Proposer, asking the Acceptors to lock-in the value, val.
// If AcceptMsg.rnd < Acceptor.rnd, the message will be ignored.
type AcceptMsg struct {
	Rnd uint32 `protobuf:"varint,1,opt,name=rnd,proto3" json:"rnd,omitempty"`
	Val *Value `protobuf:"bytes,2,opt,name=val" json:"val,omitempty"`
}

func (m *AcceptMsg) Reset()                    { *m = AcceptMsg{} }
func (*AcceptMsg) ProtoMessage()               {}
func (*AcceptMsg) Descriptor() ([]byte, []int) { return fileDescriptorSinglepaxos, []int{6} }

func (m *AcceptMsg) GetRnd() uint32 {
	if m != nil {
		return m.Rnd
	}
	return 0
}

func (m *AcceptMsg) GetVal() *Value {
	if m != nil {
		return m.Val
	}
	return nil
}

// LearnMsg is sent by an Acceptor to the Proposer, if the Acceptor agreed to lock-in the value, val.
// The LearnMsg is also sent by the Proposer in a Commit.
type LearnMsg struct {
	Rnd uint32 `protobuf:"varint,1,opt,name=rnd,proto3" json:"rnd,omitempty"`
	Val *Value `protobuf:"bytes,2,opt,name=val" json:"val,omitempty"`
}

func (m *LearnMsg) Reset()                    { *m = LearnMsg{} }
func (*LearnMsg) ProtoMessage()               {}
func (*LearnMsg) Descriptor() ([]byte, []int) { return fileDescriptorSinglepaxos, []int{7} }

func (m *LearnMsg) GetRnd() uint32 {
	if m != nil {
		return m.Rnd
	}
	return 0
}

func (m *LearnMsg) GetVal() *Value {
	if m != nil {
		return m.Val
	}
	return nil
}

type Empty struct {
}

func (m *Empty) Reset()                    { *m = Empty{} }
func (*Empty) ProtoMessage()               {}
func (*Empty) Descriptor() ([]byte, []int) { return fileDescriptorSinglepaxos, []int{8} }

func init() {
	proto.RegisterType((*Heartbeat)(nil), "singlepaxos.Heartbeat")
	proto.RegisterType((*Round)(nil), "singlepaxos.Round")
	proto.RegisterType((*Value)(nil), "singlepaxos.Value")
	proto.RegisterType((*Response)(nil), "singlepaxos.Response")
	proto.RegisterType((*PrepareMsg)(nil), "singlepaxos.PrepareMsg")
	proto.RegisterType((*PromiseMsg)(nil), "singlepaxos.PromiseMsg")
	proto.RegisterType((*AcceptMsg)(nil), "singlepaxos.AcceptMsg")
	proto.RegisterType((*LearnMsg)(nil), "singlepaxos.LearnMsg")
	proto.RegisterType((*Empty)(nil), "singlepaxos.Empty")
}
func (this *Heartbeat) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Heartbeat)
	if !ok {
		that2, ok := that.(Heartbeat)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	return true
}
func (this *Round) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Round)
	if !ok {
		that2, ok := that.(Round)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Rnd != that1.Rnd {
		return false
	}
	return true
}
func (this *Value) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Value)
	if !ok {
		that2, ok := that.(Value)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.ClientRequest != that1.ClientRequest {
		return false
	}
	return true
}
func (this *Response) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Response)
	if !ok {
		that2, ok := that.(Response)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.ClientResponse != that1.ClientResponse {
		return false
	}
	return true
}
func (this *PrepareMsg) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*PrepareMsg)
	if !ok {
		that2, ok := that.(PrepareMsg)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Rnd != that1.Rnd {
		return false
	}
	return true
}
func (this *PromiseMsg) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*PromiseMsg)
	if !ok {
		that2, ok := that.(PromiseMsg)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Rnd != that1.Rnd {
		return false
	}
	if this.Vrnd != that1.Vrnd {
		return false
	}
	if !this.Vval.Equal(that1.Vval) {
		return false
	}
	return true
}
func (this *AcceptMsg) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*AcceptMsg)
	if !ok {
		that2, ok := that.(AcceptMsg)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Rnd != that1.Rnd {
		return false
	}
	if !this.Val.Equal(that1.Val) {
		return false
	}
	return true
}
func (this *LearnMsg) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*LearnMsg)
	if !ok {
		that2, ok := that.(LearnMsg)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Rnd != that1.Rnd {
		return false
	}
	if !this.Val.Equal(that1.Val) {
		return false
	}
	return true
}
func (this *Empty) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Empty)
	if !ok {
		that2, ok := that.(Empty)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	return true
}

// Reference Gorums specific imports to suppress errors if they are not otherwise used.
var _ = codes.OK
var _ = bytes.MinRead

/* Code generated by protoc-gen-gorums - template source file: calltype_correctable_stream.tmpl */

//TODO move also the exported method signatures here

/* Code generated by protoc-gen-gorums - template source file: calltype_correctable.tmpl */

//TODO move also the exported method signatures here

/* Code generated by protoc-gen-gorums - template source file: calltype_datatypes.tmpl */

//TODO move also the exported method signatures here

type internalEmpty struct {
	nid   uint32
	reply *Empty
	err   error
}

type internalLearnMsg struct {
	nid   uint32
	reply *LearnMsg
	err   error
}

type internalPromiseMsg struct {
	nid   uint32
	reply *PromiseMsg
	err   error
}

type internalResponse struct {
	nid   uint32
	reply *Response
	err   error
}

/* Code generated by protoc-gen-gorums - template source file: calltype_future.tmpl */

//TODO move also the exported method signatures here

/* Code generated by protoc-gen-gorums - template source file: calltype_multicast.tmpl */

//TODO move also the exported method signatures here

/* Code generated by protoc-gen-gorums - template source file: calltype_quorumcall.tmpl */

//TODO move also the exported method signatures here

/* Exported types and methods for quorum call method Accept */

// Accept is invoked as a quorum call on all nodes in configuration c,
// using the same argument arg, and returns the result.
func (c *Configuration) Accept(ctx context.Context, a *AcceptMsg) (resp *LearnMsg, err error) {
	var ti traceInfo
	if c.mgr.opts.trace {
		ti.Trace = trace.New("gorums."+c.tstring()+".Sent", "Accept")
		defer ti.Finish()

		ti.firstLine.cid = c.id
		if deadline, ok := ctx.Deadline(); ok {
			ti.firstLine.deadline = deadline.Sub(time.Now())
		}
		ti.LazyLog(&ti.firstLine, false)
		ti.LazyLog(&payload{sent: true, msg: a}, false)

		defer func() {
			ti.LazyLog(&qcresult{
				reply: resp,
				err:   err,
			}, false)
			if err != nil {
				ti.SetError()
			}
		}()
	}

	expected := c.n
	replyChan := make(chan internalLearnMsg, expected)
	for _, n := range c.nodes {
		go callGRPCAccept(ctx, n, a, replyChan)
	}

	var (
		replyValues = make([]*LearnMsg, 0, expected)
		errs        []GRPCError
		quorum      bool
	)

	for {
		select {
		case r := <-replyChan:
			if r.err != nil {
				errs = append(errs, GRPCError{r.nid, r.err})
				break
			}
			if c.mgr.opts.trace {
				ti.LazyLog(&payload{sent: false, id: r.nid, msg: r.reply}, false)
			}
			replyValues = append(replyValues, r.reply)
			if resp, quorum = c.qspec.AcceptQF(replyValues); quorum {
				return resp, nil
			}
		case <-ctx.Done():
			return resp, QuorumCallError{ctx.Err().Error(), len(replyValues), errs}
		}

		if len(errs)+len(replyValues) == expected {
			return resp, QuorumCallError{"incomplete call", len(replyValues), errs}
		}
	}
}

func callGRPCAccept(ctx context.Context, node *Node, arg *AcceptMsg, replyChan chan<- internalLearnMsg) {
	reply := new(LearnMsg)
	start := time.Now()
	err := grpc.Invoke(
		ctx,
		"/singlepaxos.SinglePaxos/Accept",
		arg,
		reply,
		node.conn,
	)
	s, ok := status.FromError(err)
	if ok && (s.Code() == codes.OK || s.Code() == codes.Canceled) {
		node.setLatency(time.Since(start))
	} else {
		node.setLastErr(err)
	}
	replyChan <- internalLearnMsg{node.id, reply, err}
}

/* Exported types and methods for quorum call method ClientHandle */

// ClientHandle is invoked as a quorum call on all nodes in configuration c,
// using the same argument arg, and returns the result.
func (c *Configuration) ClientHandle(ctx context.Context, a *Value) (resp *Response, err error) {
	var ti traceInfo
	if c.mgr.opts.trace {
		ti.Trace = trace.New("gorums."+c.tstring()+".Sent", "ClientHandle")
		defer ti.Finish()

		ti.firstLine.cid = c.id
		if deadline, ok := ctx.Deadline(); ok {
			ti.firstLine.deadline = deadline.Sub(time.Now())
		}
		ti.LazyLog(&ti.firstLine, false)
		ti.LazyLog(&payload{sent: true, msg: a}, false)

		defer func() {
			ti.LazyLog(&qcresult{
				reply: resp,
				err:   err,
			}, false)
			if err != nil {
				ti.SetError()
			}
		}()
	}

	expected := c.n
	replyChan := make(chan internalResponse, expected)
	for _, n := range c.nodes {
		go callGRPCClientHandle(ctx, n, a, replyChan)
	}

	var (
		replyValues = make([]*Response, 0, expected)
		errs        []GRPCError
		quorum      bool
	)

	for {
		select {
		case r := <-replyChan:
			if r.err != nil {
				errs = append(errs, GRPCError{r.nid, r.err})
				break
			}
			if c.mgr.opts.trace {
				ti.LazyLog(&payload{sent: false, id: r.nid, msg: r.reply}, false)
			}
			replyValues = append(replyValues, r.reply)
			if resp, quorum = c.qspec.ClientHandleQF(replyValues); quorum {
				return resp, nil
			}
		case <-ctx.Done():
			return resp, QuorumCallError{ctx.Err().Error(), len(replyValues), errs}
		}

		if len(errs)+len(replyValues) == expected {
			return resp, QuorumCallError{"incomplete call", len(replyValues), errs}
		}
	}
}

func callGRPCClientHandle(ctx context.Context, node *Node, arg *Value, replyChan chan<- internalResponse) {
	reply := new(Response)
	start := time.Now()
	err := grpc.Invoke(
		ctx,
		"/singlepaxos.SinglePaxos/ClientHandle",
		arg,
		reply,
		node.conn,
	)
	s, ok := status.FromError(err)
	if ok && (s.Code() == codes.OK || s.Code() == codes.Canceled) {
		node.setLatency(time.Since(start))
	} else {
		node.setLastErr(err)
	}
	replyChan <- internalResponse{node.id, reply, err}
}

/* Exported types and methods for quorum call method Commit */

// Commit is invoked as a quorum call on all nodes in configuration c,
// using the same argument arg, and returns the result.
func (c *Configuration) Commit(ctx context.Context, a *LearnMsg) (resp *Empty, err error) {
	var ti traceInfo
	if c.mgr.opts.trace {
		ti.Trace = trace.New("gorums."+c.tstring()+".Sent", "Commit")
		defer ti.Finish()

		ti.firstLine.cid = c.id
		if deadline, ok := ctx.Deadline(); ok {
			ti.firstLine.deadline = deadline.Sub(time.Now())
		}
		ti.LazyLog(&ti.firstLine, false)
		ti.LazyLog(&payload{sent: true, msg: a}, false)

		defer func() {
			ti.LazyLog(&qcresult{
				reply: resp,
				err:   err,
			}, false)
			if err != nil {
				ti.SetError()
			}
		}()
	}

	expected := c.n
	replyChan := make(chan internalEmpty, expected)
	for _, n := range c.nodes {
		go callGRPCCommit(ctx, n, a, replyChan)
	}

	var (
		replyValues = make([]*Empty, 0, expected)
		errs        []GRPCError
		quorum      bool
	)

	for {
		select {
		case r := <-replyChan:
			if r.err != nil {
				errs = append(errs, GRPCError{r.nid, r.err})
				break
			}
			if c.mgr.opts.trace {
				ti.LazyLog(&payload{sent: false, id: r.nid, msg: r.reply}, false)
			}
			replyValues = append(replyValues, r.reply)
			if resp, quorum = c.qspec.CommitQF(replyValues); quorum {
				return resp, nil
			}
		case <-ctx.Done():
			return resp, QuorumCallError{ctx.Err().Error(), len(replyValues), errs}
		}

		if len(errs)+len(replyValues) == expected {
			return resp, QuorumCallError{"incomplete call", len(replyValues), errs}
		}
	}
}

func callGRPCCommit(ctx context.Context, node *Node, arg *LearnMsg, replyChan chan<- internalEmpty) {
	reply := new(Empty)
	start := time.Now()
	err := grpc.Invoke(
		ctx,
		"/singlepaxos.SinglePaxos/Commit",
		arg,
		reply,
		node.conn,
	)
	s, ok := status.FromError(err)
	if ok && (s.Code() == codes.OK || s.Code() == codes.Canceled) {
		node.setLatency(time.Since(start))
	} else {
		node.setLastErr(err)
	}
	replyChan <- internalEmpty{node.id, reply, err}
}

/* Exported types and methods for quorum call method Prepare */

// Prepare is invoked as a quorum call on all nodes in configuration c,
// using the same argument arg, and returns the result.
func (c *Configuration) Prepare(ctx context.Context, a *PrepareMsg) (resp *PromiseMsg, err error) {
	var ti traceInfo
	if c.mgr.opts.trace {
		ti.Trace = trace.New("gorums."+c.tstring()+".Sent", "Prepare")
		defer ti.Finish()

		ti.firstLine.cid = c.id
		if deadline, ok := ctx.Deadline(); ok {
			ti.firstLine.deadline = deadline.Sub(time.Now())
		}
		ti.LazyLog(&ti.firstLine, false)
		ti.LazyLog(&payload{sent: true, msg: a}, false)

		defer func() {
			ti.LazyLog(&qcresult{
				reply: resp,
				err:   err,
			}, false)
			if err != nil {
				ti.SetError()
			}
		}()
	}

	expected := c.n
	replyChan := make(chan internalPromiseMsg, expected)
	for _, n := range c.nodes {
		go callGRPCPrepare(ctx, n, a, replyChan)
	}

	var (
		replyValues = make([]*PromiseMsg, 0, expected)
		errs        []GRPCError
		quorum      bool
	)

	for {
		select {
		case r := <-replyChan:
			if r.err != nil {
				errs = append(errs, GRPCError{r.nid, r.err})
				break
			}
			if c.mgr.opts.trace {
				ti.LazyLog(&payload{sent: false, id: r.nid, msg: r.reply}, false)
			}
			replyValues = append(replyValues, r.reply)
			if resp, quorum = c.qspec.PrepareQF(a, replyValues); quorum {
				return resp, nil
			}
		case <-ctx.Done():
			return resp, QuorumCallError{ctx.Err().Error(), len(replyValues), errs}
		}

		if len(errs)+len(replyValues) == expected {
			return resp, QuorumCallError{"incomplete call", len(replyValues), errs}
		}
	}
}

func callGRPCPrepare(ctx context.Context, node *Node, arg *PrepareMsg, replyChan chan<- internalPromiseMsg) {
	reply := new(PromiseMsg)
	start := time.Now()
	err := grpc.Invoke(
		ctx,
		"/singlepaxos.SinglePaxos/Prepare",
		arg,
		reply,
		node.conn,
	)
	s, ok := status.FromError(err)
	if ok && (s.Code() == codes.OK || s.Code() == codes.Canceled) {
		node.setLatency(time.Since(start))
	} else {
		node.setLastErr(err)
	}
	replyChan <- internalPromiseMsg{node.id, reply, err}
}

/* Code generated by protoc-gen-gorums - template source file: node.tmpl */

// Node encapsulates the state of a node on which a remote procedure call
// can be made.
type Node struct {
	// Only assigned at creation.
	id     uint32
	addr   string
	conn   *grpc.ClientConn
	logger *log.Logger

	SinglePaxosClient SinglePaxosClient

	mu      sync.Mutex
	lastErr error
	latency time.Duration
}

func (n *Node) connect(opts ...grpc.DialOption) error {
	var err error
	n.conn, err = grpc.Dial(n.addr, opts...)
	if err != nil {
		return fmt.Errorf("dialing node failed: %v", err)
	}

	n.SinglePaxosClient = NewSinglePaxosClient(n.conn)

	return nil
}

func (n *Node) close() error {

	if err := n.conn.Close(); err != nil {
		if n.logger != nil {
			n.logger.Printf("%d: conn close error: %v", n.id, err)
		}
		return fmt.Errorf("%d: conn close error: %v", n.id, err)
	}
	return nil
}

/* Code generated by protoc-gen-gorums - template source file: qspec.tmpl */

// QuorumSpec is the interface that wraps every quorum function.
type QuorumSpec interface {
	// AcceptQF is the quorum function for the Accept
	// quorum call method.
	AcceptQF(replies []*LearnMsg) (*LearnMsg, bool)

	// ClientHandleQF is the quorum function for the ClientHandle
	// quorum call method.
	ClientHandleQF(replies []*Response) (*Response, bool)

	// CommitQF is the quorum function for the Commit
	// quorum call method.
	CommitQF(replies []*Empty) (*Empty, bool)

	// PrepareQF is the quorum function for the Prepare
	// quorum call method.
	PrepareQF(req *PrepareMsg, replies []*PromiseMsg) (*PromiseMsg, bool)
}

/* Static resources */

/* config.go */

// A Configuration represents a static set of nodes on which quorum remote
// procedure calls may be invoked.
type Configuration struct {
	id    uint32
	nodes []*Node
	n     int
	mgr   *Manager
	qspec QuorumSpec
	errs  chan GRPCError
}

// ID reports the identifier for the configuration.
func (c *Configuration) ID() uint32 {
	return c.id
}

// NodeIDs returns a slice containing the local ids of all the nodes in the
// configuration. IDs are returned in the same order as they were provided in
// the creation of the Configuration.
func (c *Configuration) NodeIDs() []uint32 {
	ids := make([]uint32, len(c.nodes))
	for i, node := range c.nodes {
		ids[i] = node.ID()
	}
	return ids
}

// Nodes returns a slice of each available node. IDs are returned in the same
// order as they were provided in the creation of the Configuration.
func (c *Configuration) Nodes() []*Node {
	return c.nodes
}

// Size returns the number of nodes in the configuration.
func (c *Configuration) Size() int {
	return c.n
}

func (c *Configuration) String() string {
	return fmt.Sprintf("configuration %d", c.id)
}

func (c *Configuration) tstring() string {
	return fmt.Sprintf("config-%d", c.id)
}

// Equal returns a boolean reporting whether a and b represents the same
// configuration.
func Equal(a, b *Configuration) bool { return a.id == b.id }

// SubError returns a channel for listening to individual node errors. Currently
// only a single listener is supported.
func (c *Configuration) SubError() <-chan GRPCError {
	return c.errs
}

/* errors.go */

// A NodeNotFoundError reports that a specified node could not be found.
type NodeNotFoundError uint32

func (e NodeNotFoundError) Error() string {
	return fmt.Sprintf("node not found: %d", e)
}

// A ConfigNotFoundError reports that a specified configuration could not be
// found.
type ConfigNotFoundError uint32

func (e ConfigNotFoundError) Error() string {
	return fmt.Sprintf("configuration not found: %d", e)
}

// An IllegalConfigError reports that a specified configuration could not be
// created.
type IllegalConfigError string

func (e IllegalConfigError) Error() string {
	return "illegal configuration: " + string(e)
}

// ManagerCreationError returns an error reporting that a Manager could not be
// created due to err.
func ManagerCreationError(err error) error {
	return fmt.Errorf("could not create manager: %s", err.Error())
}

// A QuorumCallError is used to report that a quorum call failed.
type QuorumCallError struct {
	Reason     string
	ReplyCount int
	Errors     []GRPCError
}

func (e QuorumCallError) Error() string {
	var b bytes.Buffer
	b.WriteString("quorum call error: ")
	b.WriteString(e.Reason)
	b.WriteString(fmt.Sprintf(" (errors: %d, replies: %d)", len(e.Errors), e.ReplyCount))
	if len(e.Errors) == 0 {
		return b.String()
	}
	b.WriteString("\ngrpc errors:\n")
	for _, err := range e.Errors {
		b.WriteByte('\t')
		b.WriteString(fmt.Sprintf("node %d: %v", err.NodeID, err.Cause))
		b.WriteByte('\n')
	}
	return b.String()
}

// GRPCError is used to report that a single gRPC call failed.
type GRPCError struct {
	NodeID uint32
	Cause  error
}

func (e GRPCError) Error() string {
	return fmt.Sprintf("node %d: %v", e.NodeID, e.Cause.Error())
}

/* level.go */

// LevelNotSet is the zero value level used to indicate that no level (and
// thereby no reply) has been set for a correctable quorum call.
const LevelNotSet = -1

/* mgr.go */

// Manager manages a pool of node configurations on which quorum remote
// procedure calls can be made.
type Manager struct {
	mu       sync.Mutex
	nodes    []*Node
	lookup   map[uint32]*Node
	configs  map[uint32]*Configuration
	eventLog trace.EventLog

	closeOnce sync.Once
	logger    *log.Logger
	opts      managerOptions
}

// NewManager attempts to connect to the given set of node addresses and if
// successful returns a new Manager containing connections to those nodes.
func NewManager(nodeAddrs []string, opts ...ManagerOption) (*Manager, error) {
	if len(nodeAddrs) == 0 {
		return nil, fmt.Errorf("could not create manager: no nodes provided")
	}

	m := &Manager{
		lookup:  make(map[uint32]*Node),
		configs: make(map[uint32]*Configuration),
	}

	for _, opt := range opts {
		opt(&m.opts)
	}

	for _, naddr := range nodeAddrs {
		node, err2 := m.createNode(naddr)
		if err2 != nil {
			return nil, ManagerCreationError(err2)
		}
		m.lookup[node.id] = node
		m.nodes = append(m.nodes, node)
	}

	if m.opts.trace {
		title := strings.Join(nodeAddrs, ",")
		m.eventLog = trace.NewEventLog("gorums.Manager", title)
	}

	err := m.connectAll()
	if err != nil {
		return nil, ManagerCreationError(err)
	}

	if m.opts.logger != nil {
		m.logger = m.opts.logger
	}

	if m.eventLog != nil {
		m.eventLog.Printf("ready")
	}

	return m, nil
}

func (m *Manager) createNode(addr string) (*Node, error) {
	m.mu.Lock()
	defer m.mu.Unlock()

	tcpAddr, err := net.ResolveTCPAddr("tcp", addr)
	if err != nil {
		return nil, fmt.Errorf("create node %s error: %v", addr, err)
	}

	h := fnv.New32a()
	_, _ = h.Write([]byte(tcpAddr.String()))
	id := h.Sum32()

	if _, found := m.lookup[id]; found {
		return nil, fmt.Errorf("create node %s error: node already exists", addr)
	}

	node := &Node{
		id:      id,
		addr:    tcpAddr.String(),
		latency: -1 * time.Second,
		logger:  m.logger,
	}

	return node, nil
}

func (m *Manager) connectAll() error {
	if m.opts.noConnect {
		return nil
	}

	if m.eventLog != nil {
		m.eventLog.Printf("connecting")
	}

	for _, node := range m.nodes {
		err := node.connect(m.opts.grpcDialOpts...)
		if err != nil {
			if m.eventLog != nil {
				m.eventLog.Errorf("connect failed, error connecting to node %s, error: %v", node.addr, err)
			}
			return fmt.Errorf("connect node %s error: %v", node.addr, err)
		}
	}
	return nil
}

func (m *Manager) closeNodeConns() {
	for _, node := range m.nodes {
		err := node.close()
		if err == nil {
			continue
		}
		if m.logger != nil {
			m.logger.Printf("node %d: error closing: %v", node.id, err)
		}
	}
}

// Close closes all node connections and any client streams.
func (m *Manager) Close() {
	m.closeOnce.Do(func() {
		if m.eventLog != nil {
			m.eventLog.Printf("closing")
		}
		m.closeNodeConns()
	})
}

// NodeIDs returns the identifier of each available node. IDs are returned in
// the same order as they were provided in the creation of the Manager.
func (m *Manager) NodeIDs() []uint32 {
	m.mu.Lock()
	defer m.mu.Unlock()
	ids := make([]uint32, 0, len(m.nodes))
	for _, node := range m.nodes {
		ids = append(ids, node.ID())
	}
	return ids
}

// Node returns the node with the given identifier if present.
func (m *Manager) Node(id uint32) (node *Node, found bool) {
	m.mu.Lock()
	defer m.mu.Unlock()
	node, found = m.lookup[id]
	return node, found
}

// Nodes returns a slice of each available node. IDs are returned in the same
// order as they were provided in the creation of the Manager.
func (m *Manager) Nodes() []*Node {
	m.mu.Lock()
	defer m.mu.Unlock()
	return m.nodes
}

// ConfigurationIDs returns the identifier of each available
// configuration.
func (m *Manager) ConfigurationIDs() []uint32 {
	m.mu.Lock()
	defer m.mu.Unlock()
	ids := make([]uint32, 0, len(m.configs))
	for id := range m.configs {
		ids = append(ids, id)
	}
	return ids
}

// Configuration returns the configuration with the given global
// identifier if present.
func (m *Manager) Configuration(id uint32) (config *Configuration, found bool) {
	m.mu.Lock()
	defer m.mu.Unlock()
	config, found = m.configs[id]
	return config, found
}

// Configurations returns a slice of each available configuration.
func (m *Manager) Configurations() []*Configuration {
	m.mu.Lock()
	defer m.mu.Unlock()
	configs := make([]*Configuration, 0, len(m.configs))
	for _, conf := range m.configs {
		configs = append(configs, conf)
	}
	return configs
}

// Size returns the number of nodes and configurations in the Manager.
func (m *Manager) Size() (nodes, configs int) {
	m.mu.Lock()
	defer m.mu.Unlock()
	return len(m.nodes), len(m.configs)
}

// AddNode attempts to dial to the provide node address. The node is
// added to the Manager's pool of nodes if a connection was established.
func (m *Manager) AddNode(addr string) error {
	panic("not implemented")
}

// NewConfiguration returns a new configuration given quorum specification and
// a timeout.
func (m *Manager) NewConfiguration(ids []uint32, qspec QuorumSpec) (*Configuration, error) {
	m.mu.Lock()
	defer m.mu.Unlock()

	if len(ids) == 0 {
		return nil, IllegalConfigError("need at least one node")
	}

	var cnodes []*Node
	unique := make(map[uint32]struct{})
	var deduped []uint32
	for _, nid := range ids {
		// Ensure that identical ids are only counted once.
		if _, duplicate := unique[nid]; duplicate {
			continue
		}
		unique[nid] = struct{}{}
		deduped = append(deduped, nid)

		node, found := m.lookup[nid]
		if !found {
			return nil, NodeNotFoundError(nid)
		}
		cnodes = append(cnodes, node)
	}

	// Node ids are sorted ensure a globally consistent configuration id.
	sort.Sort(idSlice(deduped))

	h := fnv.New32a()
	for _, id := range deduped {
		binary.Write(h, binary.LittleEndian, id)
	}
	cid := h.Sum32()

	conf, found := m.configs[cid]
	if found {
		return conf, nil
	}

	c := &Configuration{
		id:    cid,
		nodes: cnodes,
		n:     len(cnodes),
		mgr:   m,
		qspec: qspec,
	}
	m.configs[cid] = c

	return c, nil
}

type idSlice []uint32

func (p idSlice) Len() int           { return len(p) }
func (p idSlice) Less(i, j int) bool { return p[i] < p[j] }
func (p idSlice) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }

/* node_func.go */

// ID returns the ID of n.
func (n *Node) ID() uint32 {
	if n != nil {
		return n.id
	}
	return 0
}

// Address returns network address of n.
func (n *Node) Address() string {
	if n != nil {
		return n.addr
	}
	return ""
}

// Port returns network port of n.
func (n *Node) Port() string {
	if n != nil {
		_, port, _ := net.SplitHostPort(n.addr)
		return port
	}
	return ""
}

func (n *Node) String() string {
	if n != nil {
		return fmt.Sprintf("addr: %s", n.addr)
	}
	return ""
}

func (n *Node) FullString() string {
	if n != nil {
		n.mu.Lock()
		defer n.mu.Unlock()
		return fmt.Sprintf(
			"node %d | addr: %s | latency: %v",
			n.id, n.addr, n.latency,
		)
	}
	return ""
}

func (n *Node) setLastErr(err error) {
	n.mu.Lock()
	defer n.mu.Unlock()
	n.lastErr = err
}

// LastErr returns the last error encountered (if any) when invoking a remote
// procedure call on this node.
func (n *Node) LastErr() error {
	n.mu.Lock()
	defer n.mu.Unlock()
	return n.lastErr
}

func (n *Node) setLatency(lat time.Duration) {
	n.mu.Lock()
	defer n.mu.Unlock()
	n.latency = lat
}

// Latency returns the latency of the last successful remote procedure call
// made to this node.
func (n *Node) Latency() time.Duration {
	n.mu.Lock()
	defer n.mu.Unlock()
	return n.latency
}

type lessFunc func(n1, n2 *Node) bool

// MultiSorter implements the Sort interface, sorting the nodes within.
type MultiSorter struct {
	nodes []*Node
	less  []lessFunc
}

// Sort sorts the argument slice according to the less functions passed to
// OrderedBy.
func (ms *MultiSorter) Sort(nodes []*Node) {
	ms.nodes = nodes
	sort.Sort(ms)
}

// OrderedBy returns a Sorter that sorts using the less functions, in order.
// Call its Sort method to sort the data.
func OrderedBy(less ...lessFunc) *MultiSorter {
	return &MultiSorter{
		less: less,
	}
}

// Len is part of sort.Interface.
func (ms *MultiSorter) Len() int {
	return len(ms.nodes)
}

// Swap is part of sort.Interface.
func (ms *MultiSorter) Swap(i, j int) {
	ms.nodes[i], ms.nodes[j] = ms.nodes[j], ms.nodes[i]
}

// Less is part of sort.Interface. It is implemented by looping along the
// less functions until it finds a comparison that is either Less or
// !Less. Note that it can call the less functions twice per call. We
// could change the functions to return -1, 0, 1 and reduce the
// number of calls for greater efficiency: an exercise for the reader.
func (ms *MultiSorter) Less(i, j int) bool {
	p, q := ms.nodes[i], ms.nodes[j]
	// Try all but the last comparison.
	var k int
	for k = 0; k < len(ms.less)-1; k++ {
		less := ms.less[k]
		switch {
		case less(p, q):
			// p < q, so we have a decision.
			return true
		case less(q, p):
			// p > q, so we have a decision.
			return false
		}
		// p == q; try the next comparison.
	}
	// All comparisons to here said "equal", so just return whatever
	// the final comparison reports.
	return ms.less[k](p, q)
}

// ID sorts nodes by their identifier in increasing order.
var ID = func(n1, n2 *Node) bool {
	return n1.id < n2.id
}

// ID sorts nodes by their identifier in increasing order.
var Port = func(n1, n2 *Node) bool {
	p1, _ := strconv.Atoi(n1.Port())
	p2, _ := strconv.Atoi(n2.Port())
	return p1 < p2
}

// Latency sorts nodes by latency in increasing order. Latencies less then
// zero (sentinel value) are considered greater than any positive latency.
var Latency = func(n1, n2 *Node) bool {
	if n1.latency < 0 {
		return false
	}
	return n1.latency < n2.latency

}

// Error sorts nodes by their LastErr() status in increasing order. A
// node with LastErr() != nil is larger than a node with LastErr() == nil.
var Error = func(n1, n2 *Node) bool {
	if n1.lastErr != nil && n2.lastErr == nil {
		return false
	}
	return true
}

/* opts.go */

type managerOptions struct {
	grpcDialOpts []grpc.DialOption
	logger       *log.Logger
	noConnect    bool
	trace        bool
}

// ManagerOption provides a way to set different options on a new Manager.
type ManagerOption func(*managerOptions)

// WithGrpcDialOptions returns a ManagerOption which sets any gRPC dial options
// the Manager should use when initially connecting to each node in its
// pool.
func WithGrpcDialOptions(opts ...grpc.DialOption) ManagerOption {
	return func(o *managerOptions) {
		o.grpcDialOpts = opts
	}
}

// WithLogger returns a ManagerOption which sets an optional error logger for
// the Manager.
func WithLogger(logger *log.Logger) ManagerOption {
	return func(o *managerOptions) {
		o.logger = logger
	}
}

// WithNoConnect returns a ManagerOption which instructs the Manager not to
// connect to any of its nodes. Mainly used for testing purposes.
func WithNoConnect() ManagerOption {
	return func(o *managerOptions) {
		o.noConnect = true
	}
}

// WithTracing controls whether to trace qourum calls for this Manager instance
// using the golang.org/x/net/trace package. Tracing is currently only supported
// for regular quorum calls.
func WithTracing() ManagerOption {
	return func(o *managerOptions) {
		o.trace = true
	}
}

/* trace.go */

type traceInfo struct {
	trace.Trace
	firstLine firstLine
}

type firstLine struct {
	deadline time.Duration
	cid      uint32
}

func (f *firstLine) String() string {
	var line bytes.Buffer
	io.WriteString(&line, "QC: to config")
	fmt.Fprintf(&line, "%v deadline:", f.cid)
	if f.deadline != 0 {
		fmt.Fprint(&line, f.deadline)
	} else {
		io.WriteString(&line, "none")
	}
	return line.String()
}

type payload struct {
	sent bool
	id   uint32
	msg  interface{}
}

func (p payload) String() string {
	if p.sent {
		return fmt.Sprintf("sent: %v", p.msg)
	}
	return fmt.Sprintf("recv from %d: %v", p.id, p.msg)
}

type qcresult struct {
	ids   []uint32
	reply interface{}
	err   error
}

func (q qcresult) String() string {
	var out bytes.Buffer
	io.WriteString(&out, "recv QC reply: ")
	fmt.Fprintf(&out, "ids: %v, ", q.ids)
	fmt.Fprintf(&out, "reply: %v ", q.reply)
	if q.err != nil {
		fmt.Fprintf(&out, ", error: %v", q.err)
	}
	return out.String()
}

/* util.go */

func appendIfNotPresent(set []uint32, x uint32) []uint32 {
	for _, y := range set {
		if y == x {
			return set
		}
	}
	return append(set, x)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for SinglePaxos service

type SinglePaxosClient interface {
	Ping(ctx context.Context, in *Heartbeat, opts ...grpc.CallOption) (*Heartbeat, error)
	Prepare(ctx context.Context, in *PrepareMsg, opts ...grpc.CallOption) (*PromiseMsg, error)
	Accept(ctx context.Context, in *AcceptMsg, opts ...grpc.CallOption) (*LearnMsg, error)
	Commit(ctx context.Context, in *LearnMsg, opts ...grpc.CallOption) (*Empty, error)
	ClientHandle(ctx context.Context, in *Value, opts ...grpc.CallOption) (*Response, error)
}

type singlePaxosClient struct {
	cc *grpc.ClientConn
}

func NewSinglePaxosClient(cc *grpc.ClientConn) SinglePaxosClient {
	return &singlePaxosClient{cc}
}

func (c *singlePaxosClient) Ping(ctx context.Context, in *Heartbeat, opts ...grpc.CallOption) (*Heartbeat, error) {
	out := new(Heartbeat)
	err := grpc.Invoke(ctx, "/singlepaxos.SinglePaxos/Ping", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *singlePaxosClient) Prepare(ctx context.Context, in *PrepareMsg, opts ...grpc.CallOption) (*PromiseMsg, error) {
	out := new(PromiseMsg)
	err := grpc.Invoke(ctx, "/singlepaxos.SinglePaxos/Prepare", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *singlePaxosClient) Accept(ctx context.Context, in *AcceptMsg, opts ...grpc.CallOption) (*LearnMsg, error) {
	out := new(LearnMsg)
	err := grpc.Invoke(ctx, "/singlepaxos.SinglePaxos/Accept", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *singlePaxosClient) Commit(ctx context.Context, in *LearnMsg, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/singlepaxos.SinglePaxos/Commit", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *singlePaxosClient) ClientHandle(ctx context.Context, in *Value, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := grpc.Invoke(ctx, "/singlepaxos.SinglePaxos/ClientHandle", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for SinglePaxos service

type SinglePaxosServer interface {
	Ping(context.Context, *Heartbeat) (*Heartbeat, error)
	Prepare(context.Context, *PrepareMsg) (*PromiseMsg, error)
	Accept(context.Context, *AcceptMsg) (*LearnMsg, error)
	Commit(context.Context, *LearnMsg) (*Empty, error)
	ClientHandle(context.Context, *Value) (*Response, error)
}

func RegisterSinglePaxosServer(s *grpc.Server, srv SinglePaxosServer) {
	s.RegisterService(&_SinglePaxos_serviceDesc, srv)
}

func _SinglePaxos_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Heartbeat)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SinglePaxosServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/singlepaxos.SinglePaxos/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SinglePaxosServer).Ping(ctx, req.(*Heartbeat))
	}
	return interceptor(ctx, in, info, handler)
}

func _SinglePaxos_Prepare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrepareMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SinglePaxosServer).Prepare(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/singlepaxos.SinglePaxos/Prepare",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SinglePaxosServer).Prepare(ctx, req.(*PrepareMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _SinglePaxos_Accept_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AcceptMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SinglePaxosServer).Accept(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/singlepaxos.SinglePaxos/Accept",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SinglePaxosServer).Accept(ctx, req.(*AcceptMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _SinglePaxos_Commit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LearnMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SinglePaxosServer).Commit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/singlepaxos.SinglePaxos/Commit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SinglePaxosServer).Commit(ctx, req.(*LearnMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _SinglePaxos_ClientHandle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Value)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SinglePaxosServer).ClientHandle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/singlepaxos.SinglePaxos/ClientHandle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SinglePaxosServer).ClientHandle(ctx, req.(*Value))
	}
	return interceptor(ctx, in, info, handler)
}

var _SinglePaxos_serviceDesc = grpc.ServiceDesc{
	ServiceName: "singlepaxos.SinglePaxos",
	HandlerType: (*SinglePaxosServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Ping",
			Handler:    _SinglePaxos_Ping_Handler,
		},
		{
			MethodName: "Prepare",
			Handler:    _SinglePaxos_Prepare_Handler,
		},
		{
			MethodName: "Accept",
			Handler:    _SinglePaxos_Accept_Handler,
		},
		{
			MethodName: "Commit",
			Handler:    _SinglePaxos_Commit_Handler,
		},
		{
			MethodName: "ClientHandle",
			Handler:    _SinglePaxos_ClientHandle_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "singlepaxos.proto",
}

func (m *Heartbeat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Heartbeat) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSinglepaxos(dAtA, i, uint64(m.Id))
	}
	return i, nil
}

func (m *Round) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Round) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rnd != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSinglepaxos(dAtA, i, uint64(m.Rnd))
	}
	return i, nil
}

func (m *Value) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Value) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ClientRequest) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSinglepaxos(dAtA, i, uint64(len(m.ClientRequest)))
		i += copy(dAtA[i:], m.ClientRequest)
	}
	return i, nil
}

func (m *Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ClientResponse) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSinglepaxos(dAtA, i, uint64(len(m.ClientResponse)))
		i += copy(dAtA[i:], m.ClientResponse)
	}
	return i, nil
}

func (m *PrepareMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrepareMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rnd != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSinglepaxos(dAtA, i, uint64(m.Rnd))
	}
	return i, nil
}

func (m *PromiseMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PromiseMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rnd != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSinglepaxos(dAtA, i, uint64(m.Rnd))
	}
	if m.Vrnd != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSinglepaxos(dAtA, i, uint64(m.Vrnd))
	}
	if m.Vval != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSinglepaxos(dAtA, i, uint64(m.Vval.Size()))
		n1, err := m.Vval.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *AcceptMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AcceptMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rnd != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSinglepaxos(dAtA, i, uint64(m.Rnd))
	}
	if m.Val != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSinglepaxos(dAtA, i, uint64(m.Val.Size()))
		n2, err := m.Val.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *LearnMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LearnMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rnd != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSinglepaxos(dAtA, i, uint64(m.Rnd))
	}
	if m.Val != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSinglepaxos(dAtA, i, uint64(m.Val.Size()))
		n3, err := m.Val.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *Empty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Empty) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func encodeVarintSinglepaxos(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Heartbeat) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovSinglepaxos(uint64(m.Id))
	}
	return n
}

func (m *Round) Size() (n int) {
	var l int
	_ = l
	if m.Rnd != 0 {
		n += 1 + sovSinglepaxos(uint64(m.Rnd))
	}
	return n
}

func (m *Value) Size() (n int) {
	var l int
	_ = l
	l = len(m.ClientRequest)
	if l > 0 {
		n += 1 + l + sovSinglepaxos(uint64(l))
	}
	return n
}

func (m *Response) Size() (n int) {
	var l int
	_ = l
	l = len(m.ClientResponse)
	if l > 0 {
		n += 1 + l + sovSinglepaxos(uint64(l))
	}
	return n
}

func (m *PrepareMsg) Size() (n int) {
	var l int
	_ = l
	if m.Rnd != 0 {
		n += 1 + sovSinglepaxos(uint64(m.Rnd))
	}
	return n
}

func (m *PromiseMsg) Size() (n int) {
	var l int
	_ = l
	if m.Rnd != 0 {
		n += 1 + sovSinglepaxos(uint64(m.Rnd))
	}
	if m.Vrnd != 0 {
		n += 1 + sovSinglepaxos(uint64(m.Vrnd))
	}
	if m.Vval != nil {
		l = m.Vval.Size()
		n += 1 + l + sovSinglepaxos(uint64(l))
	}
	return n
}

func (m *AcceptMsg) Size() (n int) {
	var l int
	_ = l
	if m.Rnd != 0 {
		n += 1 + sovSinglepaxos(uint64(m.Rnd))
	}
	if m.Val != nil {
		l = m.Val.Size()
		n += 1 + l + sovSinglepaxos(uint64(l))
	}
	return n
}

func (m *LearnMsg) Size() (n int) {
	var l int
	_ = l
	if m.Rnd != 0 {
		n += 1 + sovSinglepaxos(uint64(m.Rnd))
	}
	if m.Val != nil {
		l = m.Val.Size()
		n += 1 + l + sovSinglepaxos(uint64(l))
	}
	return n
}

func (m *Empty) Size() (n int) {
	var l int
	_ = l
	return n
}

func sovSinglepaxos(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozSinglepaxos(x uint64) (n int) {
	return sovSinglepaxos(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Heartbeat) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Heartbeat{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Round) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Round{`,
		`Rnd:` + fmt.Sprintf("%v", this.Rnd) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Value) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Value{`,
		`ClientRequest:` + fmt.Sprintf("%v", this.ClientRequest) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Response) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Response{`,
		`ClientResponse:` + fmt.Sprintf("%v", this.ClientResponse) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PrepareMsg) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PrepareMsg{`,
		`Rnd:` + fmt.Sprintf("%v", this.Rnd) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PromiseMsg) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PromiseMsg{`,
		`Rnd:` + fmt.Sprintf("%v", this.Rnd) + `,`,
		`Vrnd:` + fmt.Sprintf("%v", this.Vrnd) + `,`,
		`Vval:` + strings.Replace(fmt.Sprintf("%v", this.Vval), "Value", "Value", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AcceptMsg) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AcceptMsg{`,
		`Rnd:` + fmt.Sprintf("%v", this.Rnd) + `,`,
		`Val:` + strings.Replace(fmt.Sprintf("%v", this.Val), "Value", "Value", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LearnMsg) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LearnMsg{`,
		`Rnd:` + fmt.Sprintf("%v", this.Rnd) + `,`,
		`Val:` + strings.Replace(fmt.Sprintf("%v", this.Val), "Value", "Value", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Empty) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Empty{`,
		`}`,
	}, "")
	return s
}
func valueToStringSinglepaxos(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Heartbeat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSinglepaxos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Heartbeat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Heartbeat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSinglepaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSinglepaxos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSinglepaxos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Round) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSinglepaxos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Round: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Round: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rnd", wireType)
			}
			m.Rnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSinglepaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rnd |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSinglepaxos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSinglepaxos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Value) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSinglepaxos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Value: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Value: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientRequest", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSinglepaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSinglepaxos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientRequest = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSinglepaxos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSinglepaxos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSinglepaxos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientResponse", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSinglepaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSinglepaxos
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientResponse = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSinglepaxos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSinglepaxos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrepareMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSinglepaxos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrepareMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrepareMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rnd", wireType)
			}
			m.Rnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSinglepaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rnd |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSinglepaxos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSinglepaxos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PromiseMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSinglepaxos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PromiseMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PromiseMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rnd", wireType)
			}
			m.Rnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSinglepaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rnd |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vrnd", wireType)
			}
			m.Vrnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSinglepaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vrnd |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSinglepaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSinglepaxos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Vval == nil {
				m.Vval = &Value{}
			}
			if err := m.Vval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSinglepaxos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSinglepaxos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AcceptMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSinglepaxos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AcceptMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AcceptMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rnd", wireType)
			}
			m.Rnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSinglepaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rnd |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSinglepaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSinglepaxos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Val == nil {
				m.Val = &Value{}
			}
			if err := m.Val.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSinglepaxos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSinglepaxos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LearnMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSinglepaxos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LearnMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LearnMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rnd", wireType)
			}
			m.Rnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSinglepaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rnd |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSinglepaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSinglepaxos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Val == nil {
				m.Val = &Value{}
			}
			if err := m.Val.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSinglepaxos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSinglepaxos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Empty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSinglepaxos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipSinglepaxos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSinglepaxos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSinglepaxos(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSinglepaxos
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSinglepaxos
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSinglepaxos
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthSinglepaxos
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowSinglepaxos
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipSinglepaxos(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthSinglepaxos = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSinglepaxos   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("singlepaxos.proto", fileDescriptorSinglepaxos) }

var fileDescriptorSinglepaxos = []byte{
	// 464 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x93, 0xcd, 0x6e, 0xd3, 0x40,
	0x14, 0x85, 0x3d, 0xce, 0x4f, 0x93, 0x1b, 0x5a, 0xc1, 0x95, 0x80, 0x60, 0xa4, 0x51, 0x35, 0x8a,
	0xaa, 0x6c, 0x9a, 0x48, 0x61, 0x03, 0x0b, 0x84, 0x68, 0x54, 0xa9, 0x0b, 0x90, 0x22, 0x23, 0xb1,
	0x60, 0x37, 0x4e, 0x06, 0x63, 0xc9, 0xf6, 0x18, 0xcf, 0x38, 0x82, 0x5d, 0x1f, 0x81, 0xc7, 0xe8,
	0x0b, 0xf4, 0x1d, 0x60, 0xd7, 0x25, 0x4b, 0x6a, 0x36, 0x2c, 0x79, 0x04, 0xe4, 0xc9, 0x0f, 0xb1,
	0xe5, 0xac, 0xba, 0xca, 0xcc, 0x39, 0xe7, 0x9e, 0x8c, 0x3f, 0x8f, 0xe1, 0x81, 0x0a, 0x62, 0x3f,
	0x14, 0x09, 0xff, 0x22, 0xd5, 0x28, 0x49, 0xa5, 0x96, 0xd8, 0xdb, 0x91, 0x9c, 0x81, 0x1f, 0xe8,
	0x4f, 0x99, 0x37, 0x9a, 0xcb, 0x68, 0x9c, 0x8a, 0x90, 0x7b, 0x63, 0x5f, 0xa6, 0x59, 0xa4, 0xd6,
	0x3f, 0xab, 0x11, 0xe7, 0x74, 0x27, 0xe5, 0x4b, 0x5f, 0x8e, 0x8d, 0xec, 0x65, 0x1f, 0xcd, 0xce,
	0x6c, 0xcc, 0x6a, 0x15, 0x67, 0x4f, 0xa1, 0x7b, 0x21, 0x78, 0xaa, 0x3d, 0xc1, 0x35, 0x1e, 0x81,
	0x1d, 0x2c, 0xfa, 0xe4, 0x98, 0x0c, 0x0f, 0x5d, 0x3b, 0x58, 0xb0, 0x27, 0xd0, 0x72, 0x65, 0x16,
	0x2f, 0xf0, 0x3e, 0x34, 0xd2, 0x78, 0xe3, 0x14, 0x4b, 0x76, 0x0a, 0xad, 0xf7, 0x3c, 0xcc, 0x04,
	0x0e, 0xe0, 0x70, 0x1e, 0x06, 0x22, 0xd6, 0xae, 0xf8, 0x9c, 0x09, 0xa5, 0x4d, 0xa8, 0xeb, 0x96,
	0x45, 0x36, 0x81, 0x8e, 0x2b, 0x54, 0x22, 0x63, 0x25, 0xf0, 0x04, 0x8e, 0x36, 0xe6, 0x4a, 0x59,
	0x8f, 0x54, 0x54, 0x46, 0x01, 0x66, 0xa9, 0x48, 0x78, 0x2a, 0xde, 0x2a, 0xbf, 0xe6, 0x08, 0x1f,
	0x0a, 0x5f, 0x46, 0x81, 0xaa, 0xf7, 0x11, 0xa1, 0xb9, 0x2c, 0x24, 0xdb, 0x48, 0x66, 0x8d, 0x27,
	0xd0, 0x5c, 0x2e, 0x79, 0xd8, 0x6f, 0x1c, 0x93, 0x61, 0x6f, 0x82, 0xa3, 0x5d, 0xe4, 0xe6, 0x79,
	0x5c, 0xe3, 0xb3, 0x29, 0x74, 0x5f, 0xcf, 0xe7, 0x22, 0xd1, 0xf5, 0xd5, 0x03, 0x68, 0x14, 0x2d,
	0xf6, 0xde, 0x96, 0xc2, 0x66, 0x67, 0xd0, 0x79, 0x23, 0x78, 0x1a, 0xdf, 0xa5, 0xe3, 0x00, 0x5a,
	0xe7, 0x51, 0xa2, 0xbf, 0x4e, 0x7e, 0xd8, 0xd0, 0x7b, 0x67, 0x32, 0xb3, 0x22, 0x83, 0xcf, 0xa1,
	0x39, 0x0b, 0x62, 0x1f, 0x1f, 0x95, 0x26, 0xb7, 0xef, 0xd2, 0xd9, 0xa3, 0x33, 0x0b, 0xcf, 0xe1,
	0x60, 0xcd, 0x15, 0x1f, 0x97, 0x42, 0xff, 0x69, 0x3b, 0x55, 0x63, 0x83, 0x99, 0x75, 0x2e, 0xaf,
	0xfb, 0xe4, 0xea, 0xba, 0x4f, 0xf0, 0x25, 0xb4, 0x57, 0x88, 0x2a, 0x47, 0xd8, 0x72, 0x73, 0x1e,
	0x96, 0xf4, 0x0d, 0x0a, 0xd6, 0x2c, 0x2a, 0xf0, 0x05, 0xb4, 0xa7, 0x32, 0x8a, 0x02, 0x8d, 0xf5,
	0x31, 0xa7, 0x8c, 0xc4, 0x40, 0x58, 0x8f, 0xbe, 0x82, 0x7b, 0x53, 0x73, 0x55, 0x2e, 0x78, 0xbc,
	0x08, 0x05, 0xd6, 0xc0, 0xab, 0xfc, 0xf7, 0xf6, 0x4e, 0x99, 0x82, 0xb3, 0xe1, 0xcd, 0x2d, 0xb5,
	0x7e, 0xde, 0x52, 0xeb, 0x32, 0xa7, 0xe4, 0x2a, 0xa7, 0xe4, 0x7b, 0x4e, 0xc9, 0x4d, 0x4e, 0xc9,
	0xaf, 0x9c, 0x92, 0x3f, 0x39, 0xb5, 0xfe, 0xe6, 0x94, 0x7c, 0xfb, 0x4d, 0x2d, 0xaf, 0x6d, 0xbe,
	0x92, 0x67, 0xff, 0x02, 0x00, 0x00, 0xff, 0xff, 0x67, 0xac, 0x25, 0xf5, 0x9c, 0x03, 0x00, 0x00,
}
